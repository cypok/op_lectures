%\input{header-basic.sty}
\input{header-metropolis.sty}
\input{lang-setup.sty}
\input{tools.sty}


\hypersetup{pdfauthor={Владимир Владимирович Парфиненко}}
\title{Основы программирования}
\subtitle{Лекция № 3, 16 марта 2017 г.}
\date{}
\institute{
  \vspace{1em}
  \centering
  \parbox{0.9\textwidth}{
    \includegraphics[width=\linewidth]{xkcd_compiler_complaint_ru}
    \par
    \raggedleft\tiny\url{http://xkcd.ru/371}
  }
}


\begin{document}

% it can be done only after begin{document} because of "@"
\lstMakeShortInline[style=inlineC]@

\begin{frame}[plain]
  \titlepage
\end{frame}


\section{Указатели (продолжение)}

\tikzset{
  byte lines/.style={black!30},
  block byte lines/.style={black!40},
  mem block/.style={fill=black!10},
}

\newcommand\memtop{1}
\newcommand\membottom{0}

\newcommand{\memline}[2]{
  \def\left{#1-0.45}
  \def\right{#2+0.45}

  \draw[byte lines] (\left,\membottom) grid (\right,\memtop);

  \foreach \y in {\membottom, \memtop}
    \draw (\left,\y) -- (\right,\y);

  \foreach \x in {\left, \right}
    \draw [decorate,decoration={snake,amplitude=0.3mm,segment length=3mm}]
      (\x,\membottom) -- (\x,\memtop);
}

\newcommand{\memblock}[3]{
  \def\left{#1}
  \def\right{#2}
  \def\blockname{#3}

  \draw [mem block,draw=none] (\left,\membottom) rectangle (\right,\memtop);
  \draw [block byte lines] (\left,\membottom) grid (\right,\memtop);
  \draw [mem block,fill=none] (\left,\membottom) rectangle (\right,\memtop)
    node [pos=0.5] (block \blockname) {};
}

\newcommand{\memaddr}[2]{
  \def\x{#1+0.5}
  \def\y{\membottom-0.5}
  \draw [-latex,shorten <=6pt] (\x,\y)
    node [fill=white,inner sep=0,outer sep=0] {\ttfamily\small #2} -- (\x,\membottom);
}

\newcommand{\memlabel}[3]{
  %\draw [decorate,decoration={brace, raise=0.7mm}] (#1,\memtop) -- (#2,\memtop)
  %  node [midway,yshift=4mm] {\ttfamily #3};
  \path (#1,\memtop) -- (#2,\memtop)
    node [midway,yshift=3mm,text height=1.5ex] {\ttfamily #3};
}

\newcommand{\memblockwithaddr}[5]{
  \memblock{#1}{#2}{#3}
  \memaddr{#1}{#4}
  \memaddr{#2-1}{#5}
}

\newcommand{\memblockwithaddrandlabel}[6]{
  \memblockwithaddr{#1}{#2}{#3}{#4}{#5}
  \memlabel{#1}{#2}{#6}
}

\newcommand{\memblockwithoneaddr}[4]{
  \memblock{#1}{#2}{#3}
  \memaddr{#1}{#4}
}

\newcommand{\memblockwithoneaddrandlabel}[5]{
  \memblockwithoneaddr{#1}{#2}{#3}{#4}
  \memlabel{#1}{#2}{#5}
}


\begin{frame}[fragile]{Указатель, никуда не указывающий}

  @NULL@~--- специальное константное значение, символизирующее, что указатель
  не указывает ни на какую память.
  Объявлено в заголовочном файле @stdlib.h@.
  \notep{Численное значение NULL == 0.}

  \begin{clisting}[escapechar=\!]
    int* ptr = NULL;
    !\onslide<2->!int value = *ptr; !\onslide<3->!// run time error
    !\onslide<2->!*ptr = 37; !\onslide<3->!// run time error
  \end{clisting}

  \onslide<3->
  Разные названия, но суть одна (segmentation fault, segfault, access
  violation, «Программа выполнила недопустимую операцию…», …).

\end{frame}

\begin{frame}[fragile]{Указатель, указывающий хоть куда}

  @void*@~--- специальный тип указателя, который может указывать на любые
  данные в памяти.
  Может быть приведен к любому другому типу указателей и обратно.

  \begin{clisting}[escapechar=\!]
    double x = 37;
    double* px = &x;
    void* p = px;
    int* py = p;
  \end{clisting}
  \notep{Указатель трактует указываемое содержимое как int, хотя на самом
    деле там находится double~--- это потенциальная ошибка.}

  \pause

  \vspace{1em}
  \emph{Минутка философии: «Какова природа void?»~--- спросил учитель, …}
  \url{http://thecodelesscode.com/case/5?lang=ru}
  \notep{Обязательно прочитать рассказ по ссылке.}

\end{frame}


\section{Динамическая память}

\begin{frame}[fragile]{Преимущества динамической памяти}

  \begin{itemize}[<+->]
    \item Выделяется и освобождается динамически по запросу программы.
          \notep{Внутри функции нельзя создать массив, который будет
            существовать после выхода из нее.}
    \item Размер задается динамически.
          \notep{Размер массива должен быть известен на момент компиляции
            программы.}
  \end{itemize}

  \notep{Самый гибкий и самый сложный в работе вид памяти.}

  \notep{Есть еще автоматическая и статическая память, но их описание выходит
    за рамки данной лекции. Их основные недостатки: фиксированный размер и
    недостаточно гибкое время жизни.}

\end{frame}

\begin{frame}[fragile]{Выделение блока памяти}

  \begin{clisting}[basicstyle=\ttfamily]
    void* malloc(size_t size);
  \end{clisting}
  \revertListingParskip
  Функция выделяет блок памяти размером @size@ байт и возвращает указатель на
  начало блока. \alert<2>{В случае, если память выделить не получилось,
  возвращает \texttt{NULL}.}
  Объявлена в заголовочном файле @stdlib.h@.

  \notep{malloc = Memory ALLOCate}
  \notep{size\_t - беззнаковый целочисленный тип данных, подходящий для хранения
    любого размера в байтах.}
  \notep{Другие функции для выделения памяти (calloc, realloc) выходят за рамки
    данного курса.}

\end{frame}

\begin{frame}[fragile]{Освобождение блока памяти}

  \begin{clisting}[basicstyle=\ttfamily]
    void free(void* ptr);
  \end{clisting}

  Функция освобождает блок памяти. Если @ptr@ равен @NULL@, ничего не делает.
  Объявлена в заголовочном файле @stdlib.h@.

  \pause
  После вызова значение указателя @ptr@ остается прежним, но разыменовывать его
  нельзя.

  \pause
  Неиспользуемую память нужно обязательно освобождать, иначе рано или поздно
  она может кончиться (утечка памяти).

  \notep{Утечки памяти на серверных приложениях, которые должны работать
    несколько лет, недопустимы.}

  \notep{Утечки памяти в десктопных приложениях не так критичны, но могут и
    причинять неудобства (см. современные браузеры).}

\end{frame}

\begin{frame}[fragile]{Пример: массив динамического размера}

  \begin{center}
  \begin{tikzpicture}[
      scale=0.6,
  ]
    \memline{1}{23}

    \begin{visibleenv}<3-6>
      \memblock{2}{6}{p0}
      \memblock{6}{10}{p1}
      \memblock{10}{14}{p2}
      \memblock{14}{18}{p3}
      \memblock{18}{22}{p4}

      \node [mem block] at (block p1) {???};
      \node [mem block] at (block p3) {???};
    \end{visibleenv}

    \begin{visibleenv}<3->
      \memaddr{2}{0x100}
      \memaddr{21}{0x113}
    \end{visibleenv}

    \begin{visibleenv}<3-4>
      \node [mem block] at (block p0) {???};
      \node [mem block] at (block p2) {???};
      \node [mem block] at (block p4) {???};
    \end{visibleenv}
    \begin{visibleenv}<5-6>
      \node [mem block] at (block p0) {37};
      \node [mem block] at (block p2) {37};
      \node [mem block] at (block p4) {37};
    \end{visibleenv}

    \begin{visibleenv}<7->
      \node [fill=white] at (block p0) {???};
      \node [fill=white] at (block p1) {???};
      \node [fill=white] at (block p2) {???};
      \node [fill=white] at (block p3) {???};
      \node [fill=white] at (block p4) {???};
    \end{visibleenv}

  \end{tikzpicture}
  \end{center}

  \begin{clisting}[escapechar=\!]
    int n = read_number(); // 5
    int* p; // !\comment\alt<3->{0x100}{???}!
    !\onslide<2->!p = malloc(n * sizeof(int));
    if (p == NULL) { /* error */ }
    !\onslide<4->!p[0] = p[n/2] = p[n-1] = 37;
    !\onslide<6->!free(p);
  \end{clisting}

  \notep{sizeof~--- оператор, выдающий размер типов данных. Например, на Intel
    x86 sizeof(int) == 4.}

\end{frame}


\section{Указатели на функции}

\begin{frame}[fragile]{Функции как данные}

  В языке \eng{C} с функциями можно работать как с данными:
  \begin{clisting}
    double (*my_func)(double, double) = pow;
    double x = my_func(3, 2); // x = 9.0
  \end{clisting}
  \notep{pow~--- функция возведения в степень, объявлена в файле math.h.}

  \onslide<2->
  Функция~--- это набор байтов в памяти, кодирующих тело этой функции с помощью
  машинных команд. Значит, можно взять адрес этого «набора байтов».

  Более формально:
  \begin{clisting}
    double (*my_func)(double, double) = &pow;
    double x = (*my_func)(3, 2); // x = 9.0
  \end{clisting}

  \notep{
    Произносится следующим образом: переменная my\_func~--- это
    указатель на функцию, принимающую два параметра типа double и
    возвращающую значение типа double.}

  \notep{
    Оператор взятия адреса \& для функций можно опускать (чаще всего
    опускается).}
  \notep{Оператор разыменовывания * при вызове функции можно опускать
    (чаще всего опускается).}

  \notep{
    Заметим, что вы уже встречались с типами, окружающими имя переменной: int
    arr[10][5]~--- в данном случае переменная имеет имя arr и тип int[10][5].}

\end{frame}

\begin{frame}[fragile]{Пример численного вычисления производной в точке}

  \begin{clisting}[escapechar=\!]
    double diff(double x, double (*f)(double)) {
        double dx = 0.01;
        return (f(x + dx) - f(x)) / dx;
    }
    !\onslide<3->!
    double square(double x) {
        return x * x;
    }
    !\onslide<2->!
    printf("%g\n", diff(M_PI/3, sin)); // 0.495662
    printf("%g\n", diff(M_PI/6, cos)); // -0.504322
    !\onslide<3->!printf("%g\n", diff(3, square));   // 6.01
  \end{clisting}

  \notep{
    В данном примере с помощью указателей на функции мы можем численно
    вычислять производные математических функций, которые принимают один
    параметр типа double и возвращают результат типа double.

    Заметим, что мы можем передавать параметром не только библиотечные функции
    (например, sin и cos из math.h), но и собственные функции (например,
    square).
  }

\end{frame}


\section{Символы, строки, кодировки, ...}


\plain{Конец третьей лекции}


\end{document}
