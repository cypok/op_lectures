%\input{header-basic.sty}
\input{header-metropolis.sty}
\input{lang-setup.sty}

\usepackage{tikz}
\usetikzlibrary{arrows,matrix,positioning}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{arrows}

\input{tools.sty}


\hypersetup{pdfauthor={Владимир Парфиненко}}
\title{Основы программирования}
\subtitle{Лекция № 3, 17 марта 2016 г.}
\date{}
\institute{
  \vspace{1em}
  \centering
  \parbox{0.9\textwidth}{
    \includegraphics[width=\linewidth]{xkcd_compiler_complaint_ru}
    \par
    \raggedleft\tiny\url{http://xkcd.ru/371}
  }
}

\begin{document}

% it can be done only after begin{document} because of "@"
\lstMakeShortInline[style=inlineC]@

\begin{frame}[plain]
  \titlepage
\end{frame}

\section{Массивы}

\begin{frame}[fragile]{Одномерные массивы}

  \notep{
    Мотивация: для задания квадратного уравнения нужно 3 переменные: a, b, c.
    А что делать с уравнением 10-ой степени?
    Правильно, нужен массив!
  }

  Массив~--- упорядоченный набор элементов одного типа.

  \pause
  Объявление массива @arr@, состоящего из @N@ элементов произвольного
  типа~@T@:
  \begin{clisting}
    T arr[N];
  \end{clisting}
  \revertListingParskip
  где @N@~--- константа времени компиляции.
  \notep{Без инициализации массив, объявленный в функции, содержит мусор.}

  \pause
  Пример объявления и инициализации массива:
  \begin{clisting}
    int xs[4] = {20, 10}; // {20, 10, 0, 0}
    int ys[]  = {20, 10}; // {20, 10}
  \end{clisting}
  \notep{Элементы, для которых нет явно заданного значения, инициализируются
    нулями.}
  \notep{Размер массива может быть вычислен автоматически, что может быть
    довольно удобным.}

\end{frame}

\tikzset{array matrix/.style={matrix of nodes, nodes in empty cells,
  column sep=-\pgflinewidth, row sep=-\pgflinewidth}}
\tikzset{array node/.style={draw, anchor=center, minimum height=9mm, minimum width=9mm}}
\tikzset{array index node/.style={align=center, anchor=center, text width=6mm}}

\begin{frame}[fragile]{Одномерные массивы: доступ к элементам}

  @T arr[N]@:
  \begin{center}
  \begin{tikzpicture}
    \matrix (m) [array matrix,
      row 1/.style={nodes={array node}},
      row 2/.style={nodes={array index node}}
    ]{
          &     & &        & &       \\
      @0@ & @1@ & & \ldots & & @N-1@ \\
    };
  \end{tikzpicture}
  \end{center}

  \pause
  Чтение элемента из массива по индексу @i@:
  \begin{clisting}
    T value = arr[i];
  \end{clisting}

  Запись элемента в массив по индексу @i@:
  \begin{clisting}
    arr[i] = new_value;
  \end{clisting}

  \notep{Доступ по недопустимому индексу~--- неопределенное поведение.}

\end{frame}

\begin{frame}[fragile]{Двумерные массивы}

  @T arr[N][M]@:
  \begin{center}
  \begin{tikzpicture}[
    row2 columns/.style={row 2 column #1/.style={nodes={array node}}},
    row3 columns/.style={row 3 column #1/.style={nodes={array node}}},
    row4 columns/.style={row 4 column #1/.style={nodes={array node}}},
    row columns/.style={row#1 columns/.list={2,3,4,5,6}},
  ]
    \matrix (m) [array matrix,
      column 1/.style={nodes={array index node}},
      row 1/.style={nodes={array index node}},
      row columns/.list={2,3,4},
    ]{
      & @0@ & & \ldots & & @M-1@ \\
      @0@ & & & & & \\
      \vdots & & & & & \\
      @N-1@ & & & & & \\
    };
  \end{tikzpicture}
  \end{center}
  \notep{Первая размерность~--- количество строк, как в линейной алгебре.}

  \begin{columns}[onlytextwidth,T]
    \pause
    \begin{column}{0.5\textwidth}
      \begin{clisting}
        int m[2][3] = {
          {1, 2, 3},
          {4, 5, 6}};
      \end{clisting}
    \end{column}

    \pause
    \begin{column}{0.5\textwidth}
      \begin{clisting}
        int two = m[0][1];
        m[1][2] = 66;
      \end{clisting}
    \end{column}
    \notep{two получит значение 2, а вместо 6 будет записано 66.}

  \end{columns}

\end{frame}

\begin{frame}[fragile]{Многомерные массивы}

  @T arr[N1][N2][...][Nk]@~--- все аналогично.

\end{frame}

\begin{frame}[fragile]{Передача массивов в функции}

  Зачастую, размер массива передается отдельным параметром:
  \begin{clisting}[escapechar=\!]
    int sum_values(int values[], size_t size) !\pause!{
        int sum = 0;
        for (size_t i = 0; i < size; i++) {
            sum += values[i];
        }
        return sum;
    }
    !\pause!
    int sum_pairs(int pairs[][2], size_t size) {
        // ...
    }
  \end{clisting}

  \notep{size\_t - специальный беззнаковый тип данных, которого гарантированно
    хватает для хранения размера любого массива на данной архитектуре.}

  \notep{
    Для многомерных массивов значения всех размерностей, кроме первой
    фиксируются.
  }

\end{frame}

\begin{frame}[fragile]{Передача фиксированных массивов в функции}

  Массивы жестко фиксированных размерностей передаются без дополнительных
  параметров:
  \begin{clisting}
    int sum_matrix(int matrix[3][3]) {
        int sum = 0;
        for (size_t i = 0; i < 3; i++) {
            for (size_t j = 0; j < 3; j++) {
                sum += matrix[i][j];
            }
        }
        return sum;
    }
  \end{clisting}

\end{frame}

\begin{frame}[fragile]{Возвращение массивов из функций}

  \onslide<+->
  \begin{clisting}[escapechar=\!]
    int[] reverse(int arr[], size_t size) {
      !\onslide<+->{\color{codeComment}// compile time error}!
        int result[size]; !\onslide<+->{\color{codeComment}// compile time error}!
        // ...
        return result; !\onslide<+->{\color{codeComment}// run time error}!
    }

    int original[] = {1, 2, 3};
    int reversed[] = reverse(original, 3);
      !\onslide<+->{\color{codeComment}// compile time error}!
  \end{clisting}
  \notep{Формально говоря, функция в C вообще не может иметь массив в
    качестве возвращаемого значения.}
  \notep{size~--- не может быть использована для инициализации массива, т.\,к.
    не является константой времени компиляции.}
  \notep{Более того, такой массив уничтожится после возвращения из функции, но
    об этом позже.}
  \notep{Более того, в массивную переменную нельзя ничего <<присвоить>>, что
    делать с результатом?}

\end{frame}

\begin{frame}[fragile]{«Возвращение» массивов из функций}

  \begin{clisting}
    void reverse(int dst[], int src[],
                 size_t size) {

        for (size_t i = 0; i < size; i++) {
            dst[i] = src[size - i - 1];
        }
    }

    int original[3] = {1, 2, 3};
    int reversed[3];
    reverse(reversed, original, 3);
  \end{clisting}

  \notep{Перекладываем ответственность за создание массива на вызывающую
    функцию.}

\end{frame}

\section{Указатели}

\tikzset{
  byte lines/.style={black!30},
  block byte lines/.style={black!40},
  mem block/.style={fill=black!10},
}

\newcommand\memtop{1}
\newcommand\membottom{0}

\newcommand{\memline}[2]{
  \def\left{#1+0.05}
  \def\right{#2-0.05}

  \draw[byte lines] (\left,\membottom) grid (\right,\memtop);

  \foreach \y in {\membottom, \memtop}
    \draw (\left,\y) -- (\right,\y);

  \foreach \x in {\left, \right}
    \draw [decorate,decoration={snake,amplitude=0.3mm,segment length=3mm}]
      (\x,\membottom) -- (\x,\memtop);
}

\newcommand{\memblock}[3]{
  \def\left{#1}
  \def\right{#2}
  \def\blockname{#3}

  \draw [mem block,draw=none] (\left,\membottom) rectangle (\right,\memtop);
  \draw [block byte lines] (\left,\membottom) grid (\right,\memtop);
  \draw [mem block,fill=none] (\left,\membottom) rectangle (\right,\memtop)
    node [pos=0.5] (block \blockname) {};
}

\newcommand{\memaddr}[2]{
  \def\x{#1+0.5}
  \def\y{\membottom-0.6}
  \draw [-latex] (\x,\y) node [fill=white] {\ttfamily\small #2} -- (\x,\membottom);
}

\begin{frame}[fragile]{Указатель как адрес}

  \begin{center}
  \begin{visibleenv}<2->
  \begin{tikzpicture}[
      scale=0.8,
  ]
    \memline{0.5}{7.5}
    \memline{7.5}{14.5}

    \memblock{2}{6}{x}
    \node [mem block] at (block x) {518};

    \memblock{9}{13}{y}
    \node<-7> [mem block] at (block y) {320};
    \node<8-> [mem block] at (block y) {999};

    \begin{visibleenv}<3->
      \memaddr{2}{0x20}
      \memaddr{5}{0x23}

      \memaddr{9}{0x40}
      \memaddr{12}{0x43}
    \end{visibleenv}
  \end{tikzpicture}
  \end{visibleenv}
  \end{center}

  \begin{columns}[onlytextwidth,T]
    \begin{column}{0.35\textwidth}
      \begin{clisting}[escapechar=\!]
        int x = 518;
        int y = 320;
      \end{clisting}
    \end{column}

    \begin{column}{0.65\textwidth}<4->
      \begin{clisting}[escapechar=\!]
        int *p;
        !\onslide<5->!p = &x;
        printf("%p %d\n", p, *p); // 0x20 518
        // !\color{codeComment}\& - взятие адреса!
        // !\color{codeComment}* - разыменование указателя!
        !\onslide<6->!p = &y;
        printf("%p %d\n", p, *p); // 0x40 320
        !\onslide<7->!*p = 999 ;
        !\onslide<8->!printf("%d %d\n", x, y); // 518 999
      \end{clisting}
    \end{column}

  \end{columns}

\end{frame}

\section{Виды памяти}

\section{Динамическая память}

\plain{Конец третьей лекции}

\end{document}
