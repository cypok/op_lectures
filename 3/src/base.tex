%\input{header-basic.sty}
\input{header-metropolis.sty}
\input{lang-setup.sty}

\usepackage{tikz}
\usetikzlibrary{arrows,matrix,positioning}
\usetikzlibrary{decorations.pathmorphing,decorations.pathreplacing}
\usetikzlibrary{arrows}

\input{tools.sty}


\hypersetup{pdfauthor={Владимир Парфиненко}}
\title{Основы программирования}
\subtitle{Лекция № 3, 17 марта 2016 г.}
\date{}
\institute{
  \vspace{1em}
  \centering
  \parbox{0.9\textwidth}{
    \includegraphics[width=\linewidth]{xkcd_compiler_complaint_ru}
    \par
    \raggedleft\tiny\url{http://xkcd.ru/371}
  }
}

\begin{document}

% it can be done only after begin{document} because of "@"
\lstMakeShortInline[style=inlineC]@

\begin{frame}[plain]
  \titlepage
\end{frame}

\section{Массивы}

\begin{frame}[fragile]{Одномерные массивы}

  \notep{
    Мотивация: для задания квадратного уравнения нужно 3 переменные: a, b, c.
    А что делать с уравнением 10-ой степени?
    Правильно, нужен массив!
  }

  Массив~--- упорядоченный набор элементов одного типа.

  \pause
  Объявление массива @arr@, состоящего из @N@ элементов произвольного
  типа~@T@:
  \begin{clisting}
    T arr[N];
  \end{clisting}
  \revertListingParskip
  где @N@~--- константа времени компиляции.
  \notep{Без инициализации массив, объявленный в функции, содержит мусор.}

  \pause
  Пример объявления и инициализации массива:
  \begin{clisting}
    int xs[4] = {20, 10}; // {20, 10, 0, 0}
    int ys[]  = {20, 10}; // {20, 10}
  \end{clisting}
  \notep{Элементы, для которых нет явно заданного значения, инициализируются
    нулями.}
  \notep{Размер массива может быть вычислен автоматически, что может быть
    довольно удобным.}

\end{frame}

\tikzset{array matrix/.style={matrix of nodes, nodes in empty cells,
  column sep=-\pgflinewidth, row sep=-\pgflinewidth}}
\tikzset{array node/.style={draw, anchor=center, minimum height=9mm, minimum width=9mm}}
\tikzset{array index node/.style={align=center, anchor=center, text width=6mm}}

\begin{frame}[fragile]{Одномерные массивы: доступ к элементам}

  @T arr[N]@:
  \begin{center}
  \begin{tikzpicture}
    \matrix (m) [array matrix,
      row 1/.style={nodes={array node}},
      row 2/.style={nodes={array index node}}
    ]{
          &     & &        & &       \\
      @0@ & @1@ & & \ldots & & @N-1@ \\
    };
  \end{tikzpicture}
  \end{center}

  \pause
  Чтение элемента из массива по индексу @i@:
  \begin{clisting}
    T value = arr[i];
  \end{clisting}

  Запись элемента в массив по индексу @i@:
  \begin{clisting}
    arr[i] = new_value;
  \end{clisting}

  \notep{Доступ по недопустимому индексу~--- неопределенное поведение.}

\end{frame}

\begin{frame}[fragile]{Двумерные массивы}

  @T arr[N][M]@:
  \begin{center}
  \begin{tikzpicture}[
    row2 columns/.style={row 2 column #1/.style={nodes={array node}}},
    row3 columns/.style={row 3 column #1/.style={nodes={array node}}},
    row4 columns/.style={row 4 column #1/.style={nodes={array node}}},
    row columns/.style={row#1 columns/.list={2,3,4,5,6}},
  ]
    \matrix (m) [array matrix,
      column 1/.style={nodes={array index node}},
      row 1/.style={nodes={array index node}},
      row columns/.list={2,3,4},
    ]{
      & @0@ & & \ldots & & @M-1@ \\
      @0@ & & & & & \\
      \vdots & & & & & \\
      @N-1@ & & & & & \\
    };
  \end{tikzpicture}
  \end{center}
  \notep{Первая размерность~--- количество строк, как в линейной алгебре.}

  \begin{columns}[onlytextwidth,T]
    \pause
    \begin{column}{0.5\textwidth}
      \begin{clisting}
        int m[2][3] = {
          {1, 2, 3},
          {4, 5, 6}};
      \end{clisting}
    \end{column}

    \pause
    \begin{column}{0.5\textwidth}
      \begin{clisting}
        int two = m[0][1];
        m[1][2] = 66;
      \end{clisting}
    \end{column}
    \notep{two получит значение 2, а вместо 6 будет записано 66.}

  \end{columns}

\end{frame}

\begin{frame}[fragile]{Многомерные массивы}

  @T arr[N1][N2][...][Nk]@~--- все аналогично.

\end{frame}

\begin{frame}[fragile]{Передача массивов в функции}

  Зачастую, размер массива передается отдельным параметром:
  \begin{clisting}[escapechar=\!]
    int sum_values(int values[], size_t size) !\pause!{
        int sum = 0;
        for (size_t i = 0; i < size; i++) {
            sum += values[i];
        }
        return sum;
    }
    !\pause!
    int sum_pairs(int pairs[][2], size_t size) {
        // ...
    }
  \end{clisting}

  \notep{size\_t - специальный беззнаковый тип данных, которого гарантированно
    хватает для хранения размера любого массива на данной архитектуре.}

  \notep{
    Для многомерных массивов значения всех размерностей, кроме первой
    фиксируются.
  }

\end{frame}

\begin{frame}[fragile]{Передача фиксированных массивов в функции}

  Массивы жестко фиксированных размерностей передаются без дополнительных
  параметров:
  \begin{clisting}
    int sum_matrix(int matrix[3][3]) {
        int sum = 0;
        for (size_t i = 0; i < 3; i++) {
            for (size_t j = 0; j < 3; j++) {
                sum += matrix[i][j];
            }
        }
        return sum;
    }
  \end{clisting}

\end{frame}

\begin{frame}[fragile]{Возвращение массивов из функций}

  \onslide<+->
  \begin{clisting}[escapechar=\!]
    int[] reverse(int arr[], size_t size) {
      !\onslide<+->{\comment// compile time error}!
        int result[size]; !\onslide<+->{\comment// compile time error}!
        // ...
        return result; !\onslide<+->{\comment// run time error}!
    }

    int original[] = {1, 2, 3};
    int reversed[] = reverse(original, 3);
      !\onslide<+->{\comment// compile time error}!
  \end{clisting}
  \notep{Формально говоря, функция в C вообще не может иметь массив в
    качестве возвращаемого значения.}
  \notep{size~--- не может быть использована для инициализации массива, т.\,к.
    не является константой времени компиляции.}
  \notep{Более того, такой массив уничтожится после возвращения из функции, но
    об этом позже.}
  \notep{Более того, в массивную переменную нельзя ничего <<присвоить>>, что
    делать с результатом?}

\end{frame}

\begin{frame}[fragile]{«Возвращение» массивов из функций}

  \begin{clisting}
    void reverse(int dst[], int src[],
                 size_t size) {

        for (size_t i = 0; i < size; i++) {
            dst[i] = src[size - i - 1];
        }
    }

    int original[3] = {1, 2, 3};
    int reversed[3];
    reverse(reversed, original, 3);
  \end{clisting}

  \notep{Перекладываем ответственность за создание массива на вызывающую
    функцию.}

\end{frame}

\section{Указатели}

\tikzset{
  byte lines/.style={black!30},
  block byte lines/.style={black!40},
  mem block/.style={fill=black!10},
}

\newcommand\memtop{1}
\newcommand\membottom{0}

\newcommand{\memline}[2]{
  \def\left{#1-0.45}
  \def\right{#2+0.45}

  \draw[byte lines] (\left,\membottom) grid (\right,\memtop);

  \foreach \y in {\membottom, \memtop}
    \draw (\left,\y) -- (\right,\y);

  \foreach \x in {\left, \right}
    \draw [decorate,decoration={snake,amplitude=0.3mm,segment length=3mm}]
      (\x,\membottom) -- (\x,\memtop);
}

\newcommand{\memblock}[3]{
  \def\left{#1}
  \def\right{#2}
  \def\blockname{#3}

  \draw [mem block,draw=none] (\left,\membottom) rectangle (\right,\memtop);
  \draw [block byte lines] (\left,\membottom) grid (\right,\memtop);
  \draw [mem block,fill=none] (\left,\membottom) rectangle (\right,\memtop)
    node [pos=0.5] (block \blockname) {};
}

\newcommand{\memaddr}[2]{
  \def\x{#1+0.5}
  \def\y{\membottom-0.5}
  \draw [-latex,shorten <=6pt] (\x,\y)
    node [fill=white,inner sep=0,outer sep=0] {\ttfamily\small #2} -- (\x,\membottom);
}

\newcommand{\memlabel}[3]{
  %\draw [decorate,decoration={brace, raise=0.7mm}] (#1,\memtop) -- (#2,\memtop)
  %  node [midway,yshift=4mm] {#3};
  \path (#1,\memtop) -- (#2,\memtop)
    node [midway,yshift=3mm,text height=1.5ex] {#3};
}

\newcommand{\memblockwithaddr}[5]{
  \memblock{#1}{#2}{#3}
  \memaddr{#1}{#4}
  \memaddr{#2-1}{#5}
}

\newcommand{\memblockwithlabel}[4]{
  \memblock{#1}{#2}{#3}
  \memlabel{#1}{#2}{#4}
}

\newcommand{\memblockwithaddrandlabel}[6]{
  \memblockwithaddr{#1}{#2}{#3}{#4}{#5}
  \memlabel{#1}{#2}{#6}
}

\begin{frame}[fragile]{Указатель как адрес}

  \begin{center}
  \begin{visibleenv}<2->
  \begin{tikzpicture}[
      scale=0.8,
  ]

    \memline{1}{7}
    \memblock{2}{6}{x}
    \node [mem block] at (block x) {518};

    \memline{8}{14}
    \memblock{9}{13}{y}
    \node<-7> [mem block] at (block y) {320};
    \node<8-> [mem block] at (block y) {999};

    \begin{visibleenv}<3->
      \memaddr{2}{0x20}
      \memaddr{5}{0x23}

      \memaddr{9}{0x40}
      \memaddr{12}{0x43}
    \end{visibleenv}
  \end{tikzpicture}
  \end{visibleenv}
  \end{center}

  \begin{columns}[onlytextwidth,T]
    \begin{column}{0.35\textwidth}
      \begin{clisting}[escapechar=\!]
        int x = 518;
        int y = 320;
      \end{clisting}
    \end{column}

    \begin{column}{0.65\textwidth}<4->
      \begin{clisting}[escapechar=\!]
        int* p;
        !\onslide<5->!// !\comment\& - взятие адреса!
        // !\comment* - разыменование указателя!
        p = &x;
        printf("%p %d\n", p, *p); // 0x20 518
        !\onslide<6->!p = &y;
        printf("%p %d\n", p, *p); // 0x40 320
        !\onslide<7->!*p = 999;
        !\onslide<9->!printf("%d %d\n", x, y); // 518 999
      \end{clisting}
    \end{column}

  \end{columns}

  \notep{int*  - указатель на int, т.е. адрес памяти, где лежит int.}
  \notep{Заметьте, y поменяло свое значение, хотя прямых записей в него не было.}

\end{frame}

\begin{frame}[fragile]{Пример: возврат двух значений из функции}

  \begin{center}
  \begin{visibleenv}<3->
  \begin{tikzpicture}[
      scale=0.8,
  ]
    \memline{1}{7}
    \memblockwithaddrandlabel{2}{6}{q}%
      {0x20}{0x23}%
      {\ttfamily q}

    \memline{8}{14}
    \memblockwithaddrandlabel{9}{13}{r}%
      {0x40}{0x43}%
      {\ttfamily r}


    \node<4-8> [mem block] at (block q) {???};
    \node<9-> [mem block] at (block q) {12};

    \node<4-10> [mem block] at (block r) {???};
    \node<11-> [mem block] at (block r) {3};

  \end{tikzpicture}
  \end{visibleenv}
  \end{center}

  \begin{columns}[onlytextwidth,T]
    \begin{column}{0.5\textwidth}
      \begin{clisting}[escapechar=\!]
        void divide(
            int a, int b, !\onslide<6->{\comment// 123, 10}!
            int* pq, !\onslide<7->{\comment// 0x20}!
            int* pr) !\onslide<7->{\comment// 0x40}!
        {
          *pq = a / b; !\onslide<8->{\comment// *(0x20) = 12}!
          *pr = a % b; !\onslide<10->{\comment// *(0x40) = 3}!
        }
      \end{clisting}
    \end{column}

    \begin{column}{0.5\textwidth}<2->
      \begin{clisting}[escapechar=\!]
        int x = 123, y = 10;
        int q, r;

        !\onslide<5->!divide(x, y, &q, &r);
        !\onslide<12->!printf("%d = %d * %d + %d\n",
          x, y, q, r);
        // 123 = 10 * 12 + 3
      \end{clisting}
    \end{column}

  \end{columns}

  \notep{x, y передаются по значению, q, r передаются по указателю.}
  \notep{Модификация a и b в функции никак не изменит значения x, y.}

\end{frame}

\begin{frame}[fragile]{Представление указателя}

  \begin{center}
  \begin{tikzpicture}[
      scale=0.7,
  ]
    \memline{1}{4}
    \memline{5}{11}cypok/fix-ant-build
    \memline{12}{18}

    \memblockwithlabel{2}{3}{x}%
      {\ttfamily x}
    \memaddr{2}{0x20}
    \node<-6> [mem block] at (block x) {37};
    \node<7-> [mem block] at (block x) {42};


    \begin{visibleenv}<2->
      \memblockwithaddrandlabel{6}{10}{px}%
        {0x80}{0x84}%
        {\ttfamily px}
      \node<3-> [mem block] at (block px) {\ttfamily 0x20};
    \end{visibleenv}

    \begin{visibleenv}<4->
      \memblockwithaddrandlabel{13}{17}{ppx}%
        {0xE0}{0xE4}%
        {\ttfamily ppx}
      \node<5-> [mem block] at (block ppx) {\ttfamily 0x80};
    \end{visibleenv}

  \end{tikzpicture}
  \end{center}

  \begin{clisting}[escapechar=\!]
    char x = 37;
    !\onslide<2->!char* px = &x;
    !\onslide<4->!char** ppx = &px;

    !\onslide<6->!**ppx = 42;
  \end{clisting}

  \notep{T* для любого T всегда занимает одинаковое количество байт на одной
  платформе. Обычно так: 32-битные платформы - 4 байта, 64-битные - 8 байт.}
  \notep{Адрес хранится как беззнаковое число.}

\end{frame}




\section{Виды памяти}

\section{Динамическая память}

\plain{Конец третьей лекции}

\end{document}

